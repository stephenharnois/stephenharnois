<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tutorial | Stephen Harnois]]></title>
  <link href="http://stephenharnois.github.io/stephenharnois/blog/categories/tutorial/atom.xml" rel="self"/>
  <link href="http://stephenharnois.github.io/stephenharnois/"/>
  <updated>2013-06-20T18:25:41-04:00</updated>
  <id>http://stephenharnois.github.io/stephenharnois/</id>
  <author>
    <name><![CDATA[Stephen Harnois]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Koans]]></title>
    <link href="http://stephenharnois.github.io/stephenharnois/blog/2013/06/20/ruby-koans/"/>
    <updated>2013-06-20T18:09:00-04:00</updated>
    <id>http://stephenharnois.github.io/stephenharnois/blog/2013/06/20/ruby-koans</id>
    <content type="html"><![CDATA[<p>The <a href="http://rubykoans.com/">Ruby Koans</a> tutorial is different from most tutorial because you use the language you are learning to run the tutorial.
Most of the challenges were review from previous Ruby tutorials I have taken.
There were several projects included in the Ruby Koans that were very difficult.
The are a lot of good descriptions of the projects on Stack Overflow if you get stuck.
Overall this was a very good tutorial and I learned a lot.</p>

<p>Up next is more classes from <a href="http://www.codeschool.com/paths/ruby">Code School</a>.
See you next time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails Tutorial: Chapter 11]]></title>
    <link href="http://stephenharnois.github.io/stephenharnois/blog/2013/06/12/ruby-on-rails-tutorial-chapter-11/"/>
    <updated>2013-06-12T15:13:00-04:00</updated>
    <id>http://stephenharnois.github.io/stephenharnois/blog/2013/06/12/ruby-on-rails-tutorial-chapter-11</id>
    <content type="html"><![CDATA[<p>The final chapter of the tutorial is all about adding the ability to follow users.
The sections of the chapter are setting up the relationship model, creating a web interface for following users and setting up the status feed.</p>

<!-- more -->


<h2>Relationship Model</h2>

<p>To setup the relationship between followers and the people they follow Rails has an interesting solution:</p>

<pre><code>has_many :followed_users, through: :relationships, source: :followed
</code></pre>

<p>This code sets up a relationship between users through the relationship table.
The user model then needs functions to determine if you are following a user and a function to setup a following relationship.
There also needs to be a way to destroy the relationship between users.
Since this relationship has been setup the reverse relationship can be collected from the table very easily.</p>

<h2>Web Interface</h2>

<p>On the user profile there will be a number representing the people you are following and the people who follow you.
The first step is to add the following and followers routes to the routes file.
Then get the user and check the relationship table to find the followed and followers counts.
Next a button is added to each users feed to let you know if you are following that user.
If you are following them the button will say unfollow and if not following them then the button says follow.
The final piece is to add the gravatar images for each of the people you are following below the number of followers.</p>

<h2>Status Feed</h2>

<p>The status feed needs to contain the list of all of your posts combined with the post of the people you are following.
The following is a blend of Rails, Ruby and SQL that will get the list of microposts to include in the status feed:</p>

<pre><code>followed_user_ids = "SELECT followed_id FROM relationships
                     WHERE follower_id = :user_id"
where("user_id IN (#{followed_user_ids}) OR user_id = :user_id", user_id: user.id)
</code></pre>

<p>That finishes up the status feed section of the app.
This tutorial had time when it was difficult, but if you stick with it and read over the sections a few times I found that it clicked.</p>

<p>That is it for this tutorial next I will be moving on to the <a href="http://rubykoans.com/">Ruby Koans</a> tutorial.
Ruby Koans uses ruby itself to teach the language.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails Tutorial: Chapter 10]]></title>
    <link href="http://stephenharnois.github.io/stephenharnois/blog/2013/06/10/ruby-on-rails-tutorial-chapter-10/"/>
    <updated>2013-06-10T15:57:00-04:00</updated>
    <id>http://stephenharnois.github.io/stephenharnois/blog/2013/06/10/ruby-on-rails-tutorial-chapter-10</id>
    <content type="html"><![CDATA[<p>This chapter was all about allowing the users ato enter their micro posts and to manipulate them.
The section are setting up the micropost model, displaying the microposts and then allowing the microposts to be manipulated by the user.</p>

<!-- more -->


<h2>Micropost Model</h2>

<p>The microposts model is simple it only contains the actual post from the user and the user id of the user.
The main idea for this section is to setup a relationship between the user and his posts.
Since one use can have many posts and a post can only belong to a single user.
Rails allows you to set this relationship up very easily.</p>

<pre><code>:Micropost Model
belongs_to :user

:User Model
has_many :microposts
</code></pre>

<p>Those few lines is all it takes for Rails to establish the relationship.
The last piece of setup for the micropost model is how to handle getting rid of users posts when the user is deleted from the system.
Rails has the following solution:</p>

<pre><code>:User Model
has_many :microposts, dependent: :destroy
</code></pre>

<p>The dependent destroy option on the has many relationship will remove all associated posts when the user is deleted from the system.</p>

<h2>Displaying Microposts</h2>

<p>The microposts will be displayed on the users profile page, so a section is added there to display the microposts.
To handle the pagination we will use the will_paginate ruby from the previous chapter with one small addition.</p>

<pre><code>&lt;%= will_paginate @microposts %&gt;
</code></pre>

<p>Since we are on the user view coming from the user controller we have to tell will_paginate that we want the micropost data to be paginated.
The last step to displaying microposts is a little bit of CSS styling and they are done.</p>

<h2>Manipulating Microposts</h2>

<p>Now we have to add the CRUD elements to microposts just like they were for users.
Since now we now when a user is logged in we can check that on the home page and display a micropost form for users and a signup form for those who have not signed in yet.
Since the user and micropost have the relationship defined above we can do something clever and define the new micropost based on the current user, like so:</p>

<pre><code>@micropost = current_user.microposts.build if signed_in?
</code></pre>

<p>This one line will create a new micropost form for the user if they are signed in.
To destroy a micropost you just have to call the destroy method on the micropost.</p>

<p>Thats it for chapter 10 next is the final chapter 11 where users can follow other users.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails Tutorial: Chapter 9]]></title>
    <link href="http://stephenharnois.github.io/stephenharnois/blog/2013/06/09/ruby-on-rails-tutorial-chapter-9/"/>
    <updated>2013-06-09T15:27:00-04:00</updated>
    <id>http://stephenharnois.github.io/stephenharnois/blog/2013/06/09/ruby-on-rails-tutorial-chapter-9</id>
    <content type="html"><![CDATA[<p>This Chapter is all about manipulating users and what they are allowed to do on the system.
The topics covered in this Chapter were updating users, authorization, showing all users on the system and deleting users.</p>

<!-- more -->


<h2>Updating Users</h2>

<p>Editing users is very similar to creating new users, we just have to call the update cation instead of the new action.
We can use the find method to get the user id from the params structure and search the database for that user.
If there is a problem with the edit send the use back and display error.
On a successful edit just go to the users profile page.
This section was very similar to the work from the previous chapter.</p>

<h2>Authorization</h2>

<p>The first step is to check if the user is signed in on every page and if not redirect them to the signin page.
We will also display a notice to the user to sign in.
I like how Rails uses the before filters in the controller to verify the correct user is signed in.</p>

<pre><code>before_filter :signed_in_user, only: [:edit, :update]
before_filter :correct_user,   only: [:edit, :update]
</code></pre>

<p>The next interesting piece was a way to remember what page the user was looking for and forward them to that page once signed in.</p>

<h2>Showing All Users</h2>

<p>The next step is to create a page to list all of the users, but we only want to show the users if a current user is signed in first.
We then grab all of the users from the database and display them on the page.
However this can cause a problem when the site grows ad has thousands of users.
The solution is to use pagination, which is to only grab a page worth of users from the database.
Then if you want to see more users you can request the next page of users.
The tutorial uses <a href="https://github.com/mislav/will_paginate/wiki">will_paginate</a> gem to handle pagination.
Since the user view will be getting its data from the users controller you can add pagination simply by adding the following:</p>

<pre><code>:In the View
&lt;%= will_paginate %&gt;

:In the controller
@users = User.paginate(page: params[:page])
</code></pre>

<h2>Deleting Users</h2>

<p>The final piece of the puzzle is to allow admin users to remove users from the system.
We have to add a field to the users database that defines an administrative user.
Then we go to the list of all users and add a field to delete all users that are not the current user.
The actual removal is simple, just by calling the destroy method on the user and then return an acknowledgement to the user.</p>

<p>Thats it for Chapter 9 up next is Chapter 10.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails Tutorial: Chapter 8]]></title>
    <link href="http://stephenharnois.github.io/stephenharnois/blog/2013/06/08/ruby-on-rails-tutorial-chapter-8/"/>
    <updated>2013-06-08T15:48:00-04:00</updated>
    <id>http://stephenharnois.github.io/stephenharnois/blog/2013/06/08/ruby-on-rails-tutorial-chapter-8</id>
    <content type="html"><![CDATA[<p>Chapter 8 is about Signing the user in and out.
The three sections in this chapter was setting up sessions, handling signin failure and handling signin success.</p>

<!-- more -->


<h2>Sessions</h2>

<p>Sessions are a semi-permanent connection between server and client.
Ruby uses cookies to store the session data.
When a user signs in a new session has to be created.
When a user signs out the existing session has to be created.
Ruby does this using routes to point to the correct function.</p>

<h2>Signin Failure</h2>

<p>First a new signin page has to be created to setup the new session.
Once the user signs in their password is compared to the hash stored in the database.
I like the way that Ruby authenticates users.</p>

<pre><code>user &amp;&amp; user.authenticate(params[:session][:password])
</code></pre>

<p>This solution is very elegant because if the user does not exist then user will be nil and it will stop comparing there.
If the user exists and the password is wrong then signin will fail.
The only way for the user login to succeed is if both user name and password match what is in the database.
The flash that we setup last chapter is used here again to alert of a failed signin attempt.
Once signin fails the user is redirected to signin again.</p>

<h2>Signin Success</h2>

<p>Once the user signs in correctly we send them to the profile page.
To remember if a user has signed in we generate a random token and store that in there session.
I like the way Rails handles expiring cookies, normally cookies expire at some time.
If you want them to last a long time you would do the following:</p>

<pre><code>cookies.20.years.from_now
cookies.premanent
</code></pre>

<p>These two statements will have the same effect, since Rails has added a special permanent method.
The current user is also stored in the session so that authorization can be handled.
The last thing to handle is destroying the session once the user logs out, which is done with the delete method of the cookie.</p>

<p>Thats it for this Chapter next is Chapter 9.</p>
]]></content>
  </entry>
  
</feed>
